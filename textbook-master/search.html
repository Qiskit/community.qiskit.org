<!DOCTYPE html>
<html lang="en">
  

  <script>
(function () {
  'use strict'
  window.digitalData = {
    page: {
      pageInfo: {
        productTitle: 'IBM Q Experience',
        analytics: {
          category: 'Qiskit.org'
        }
      }
    }
  }
  window._analytics = {
    segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw'
  }
}());
</script>
<script async src="https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js"></script>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Search the site</title>
  <meta name="description" content="        ">

  <link rel="canonical" href="https://community.qiskit.org/textbook/search">
  <link rel="alternate" type="application/rss+xml" title="Qiskit Textbook" href="https://community.qiskit.org/textbook/feed.xml">

  <meta property="og:url"         content="https://community.qiskit.org/textbook/search" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Search the site" />
<meta property="og:description" content="        " />
<meta property="og:image"       content="https://community.qiskit.org/textbook/images/logo/logo.png" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://community.qiskit.org/textbook/search",
  "headline": "Search the site",
  "datePublished": "2019-12-07T21:10:34+00:00",
  "dateModified": "2019-12-07T21:10:34+00:00",
  "description": "        ",
  "author": {
    "@type": "Person",
    "name": "The Qiskit Team"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://community.qiskit.org/textbook",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://community.qiskit.org/textbook",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/textbook/assets/css/styles.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css ">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/textbook/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>

  <!-- DOM updating function -->
  <script>
const runWhenDOMLoaded = cb => {
  if (document.readyState != 'loading') {
    cb()
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', cb)
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') cb()
    })
  }
}

// Helper function to init things quickly
initFunction = function(myfunc) {
  runWhenDOMLoaded(myfunc);
  document.addEventListener('turbolinks:load', myfunc);
};
</script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/textbook';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script>
const initAnchors = () => {
  if (window.anchors === undefined) {
    setTimeout(initAnchors, 250)
    return
  }
  anchors.add("main h1, main h2, main h3, main h4")
}

initFunction(initAnchors);
</script>


  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Selectors for elements on the page -->
  <script>
/**
 * Select various elements on the page for later use
 */

// IDs we'll attach to cells
const codeCellId = index => `codecell${index}`
const inputCellId = index => `inputcell${index}`

pageElements = {}

// All code cells
findCodeCells = function() {
    var codeCells = document.querySelectorAll('div.c-textbook__content > div.highlighter-rouge > div.highlight > pre, div.input_area pre, div.text_cell_render div.highlight pre')
    pageElements['codeCells'] = codeCells;

    codeCells.forEach((codeCell, index) => {
      const id = codeCellId(index)
      codeCell.setAttribute('id', id)
    })
};

initFunction(findCodeCells);

// All cells in general
findInputCells = function() {
    var inputCells = document.querySelectorAll('div.jb_cell')
    pageElements['inputCells'] = inputCells;

    inputCells.forEach((inputCell, index) => {
        const id = inputCellId(index)
        inputCell.setAttribute('id', id)
    })
};

initFunction(findInputCells);
</script>

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->



  <!-- Load the auto-generating TOC -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js" async></script>
<script>
const initToc = () => {
  if (window.tocbot === undefined) {
    setTimeout(initToc, 250)
    return
  }

  // Check whether we have any sidebar content. If not, then show the sidebar earlier.
  var SIDEBAR_CONTENT_TAGS = ['.tag_full_width', '.tag_popout'];
  var sidebar_content_query = SIDEBAR_CONTENT_TAGS.join(', ')
  if (document.querySelectorAll(sidebar_content_query).length === 0) {
    document.querySelector('nav.onthispage').classList.add('no_sidebar_content')
  }

  // Initialize the TOC bot
  tocbot.init({
    tocSelector: 'nav.onthispage',
    contentSelector: '.c-textbook__content',
    headingSelector: 'h2, h3',
    orderedList: false,
    collapseDepth: 6,
    listClass: 'toc__menu',
    activeListItemClass: "",  // Not using
    activeLinkClass: "", // Not using
  });

}
initFunction(initToc);
</script>


  <!-- Google analytics -->
  <script src="/textbook/assets/js/ga.js" async></script>

  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/textbook/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/textbook/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/textbook/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  

  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script>
/**
 * Set up copy/paste for code blocks
 */
const clipboardButton = id =>
  `<a id="copy-button-${id}" class="btn copybtn o-tooltip--left" data-tooltip="Copy" data-clipboard-target="#${id}">
    <img src="/textbook/assets/images/copy-button.svg" alt="Copy to clipboard">
  </a>`

// Clears selected text since ClipboardJS will select the text when copying
const clearSelection = () => {
  if (window.getSelection) {
    window.getSelection().removeAllRanges()
  } else if (document.selection) {
    document.selection.empty()
  }
}

// Changes tooltip text for two seconds, then changes it back
const temporarilyChangeTooltip = (el, newText) => {
  const oldText = el.getAttribute('data-tooltip')
  el.setAttribute('data-tooltip', newText)
  setTimeout(() => el.setAttribute('data-tooltip', oldText), 2000)
}

const addCopyButtonToCodeCells = () => {
  // If ClipboardJS hasn't loaded, wait a bit and try again. This
  // happens because we load ClipboardJS asynchronously.
  if (window.ClipboardJS === undefined) {
    setTimeout(addCopyButtonToCodeCells, 250)
    return
  }

  pageElements['codeCells'].forEach((codeCell) => {
    const id = codeCell.getAttribute('id')
    if (document.getElementById("copy-button" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', clipboardButton(id));
    }
  })

  const clipboard = new ClipboardJS('.copybtn')
  clipboard.on('success', event => {
    clearSelection()
    temporarilyChangeTooltip(event.trigger, 'Copied!')
  })

  clipboard.on('error', event => {
    temporarilyChangeTooltip(event.trigger, 'Failed to copy')
  })

  // Get rid of clipboard before the next page visit to avoid memory leak
  document.addEventListener('turbolinks:before-visit', () =>
    clipboard.destroy()
  )
}

initFunction(addCopyButtonToCodeCells);
</script>


  <!-- Hide cell code -->
  <script>
    /**
    Add buttons to hide code cells
    */


    var setCodeCellVisibility = function (inputField, kind) {
        // Update the image and class for hidden
        var id = inputField.getAttribute('data-id');
        var codeCell = document.querySelector(`#${id} div.highlight`);

        if (kind === "visible") {
            codeCell.classList.remove('hidden');
            inputField.checked = true;
        } else {
            codeCell.classList.add('hidden');
            inputField.checked = false;
        }
    }

    var toggleCodeCellVisibility = function (event) {
        // The label is clicked, and now we decide what to do based on the input field's clicked status
        if (event.target.tagName === "LABEL") {
            var inputField = event.target.previousElementSibling;
        } else {
            // It is the span inside the target
            var inputField = event.target.parentElement.previousElementSibling;
        }

        if (inputField.checked === true) {
            setCodeCellVisibility(inputField, "visible");
        } else {
            setCodeCellVisibility(inputField, "hidden");
        }
    }


    // Button constructor
    const hideCodeButton = id => `<input class="hidebtn" type="checkbox" id="hidebtn${id}" data-id="${id}"><label title="Toggle cell" for="hidebtn${id}" class="plusminus"><span class="pm_h"></span><span class="pm_v"></span></label>`

    var addHideButton = function () {
        // If a hide button is already added, don't add another
        if (document.querySelector('div.tag_hide_input input') !== null) {
            return;
        }

        // Find the input cells and add a hide button
        pageElements['inputCells'].forEach(function (inputCell) {
            if (!inputCell.classList.contains("tag_hide_input")) {
                // Skip the cell if it doesn't have a hidecode class
                return;
            }

            const id = inputCell.getAttribute('id')

            // Insert the button just inside the end of the next div
            inputCell.querySelector('div.input').insertAdjacentHTML('beforeend', hideCodeButton(id))

            // Set up the visibility toggle
            hideLink = document.querySelector(`#${id} div.inner_cell + input + label`);
            hideLink.addEventListener('click', toggleCodeCellVisibility)
        });
    }


    // Initialize the hide buttos
    var initHiddenCells = function () {
        // Add hide buttons to the cells
        addHideButton();

        // Toggle the code cells that should be hidden
        document.querySelectorAll('div.tag_hide_input input').forEach(function (item) {
            setCodeCellVisibility(item, 'hidden');
            item.checked = true;
        })
    }

    initFunction(initHiddenCells);

</script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/textbook/assets/css/styles.css",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://delapuente.github.io/qiskit-textbook"><img src="/textbook/images/logo/logo.png" class="textbook_logo" id="sidebar-logo" data-turbolinks-permanent/></a>
  <h2 class="c-sidebar__title">Qiskit Textbook</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/preface.html"
        >
          
          Preface
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/upcoming.html"
        >
          
          Upcoming
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-prerequisites/python-and-jupyter-notebooks.html"
        >
          
            0.
          
          Prerequisites
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/python-and-jupyter-notebooks.html"
                >
                  
                    0.1
                  
                  Python and Jupyter Notebooks
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/qiskit.html"
                >
                  
                    0.2
                  
                  Qiskit
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/linear_algebra.html"
                >
                  
                    0.3
                  
                  Linear Algebra
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-states/introduction.html"
        >
          
            1.
          
          Quantum States and Qubits
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/introduction.html"
                >
                  
                    1.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/atoms-computation.html"
                >
                  
                    1.2
                  
                  The Atoms of Computation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/unique-properties-qubits.html"
                >
                  
                    1.3
                  
                  The Unique Properties of Qubits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/writing-down-qubit-states.html"
                >
                  
                    1.4
                  
                  Writing Down Qubit States
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/pauli-matrices-bloch-sphere.html"
                >
                  
                    1.5
                  
                  Pauli Matrices and the Bloch Sphere
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/states-many-qubits.html"
                >
                  
                    1.6
                  
                  States for Many Qubits
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-gates/introduction.html"
        >
          
            2.
          
          Single Qubits and Multi-Qubits gates
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/introduction.html"
                >
                  
                    2.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/quantum-gates.html"
                >
                  
                    2.2
                  
                  Quantum Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/fun-matrices.html"
                >
                  
                    2.3
                  
                  Fun with Matrices
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/standard-gate-set.html"
                >
                  
                    2.4
                  
                  The Standard Gate Set
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/proving-universality.html"
                >
                  
                    2.5
                  
                  Proving Universality
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/basic-circuit-identities.html"
                >
                  
                    2.6
                  
                  Basic Circuit Identities
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-ex/ex1.html"
        >
          
          Problems
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex1.html"
                >
                  
                  Set 1. Classical Logic Gates with Quantum Circuits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex2.html"
                >
                  
                  Set 2. Basic Synthesis of Single-Qubit Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex3.html"
                >
                  
                  Set 3. Building the Best AND Gate
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-algorithms/teleportation.html"
        >
          
            3.
          
          Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/teleportation.html"
                >
                  
                    3.1
                  
                  Quantum Teleportation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/deutsch-josza.html"
                >
                  
                    3.2
                  
                  Deutsch-Josza Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/bernstein-vazirani.html"
                >
                  
                    3.3
                  
                  Bernstein-Vazirani Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/simon.html"
                >
                  
                    3.4
                  
                  Simon's Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/quantum-fourier-transform.html"
                >
                  
                    3.5
                  
                  Quantum Fourier Transform
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/quantum-phase-estimation.html"
                >
                  
                    3.6
                  
                  Quantum Phase Estimation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/grover.html"
                >
                  
                    3.7
                  
                  Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-applications/vqe-molecules.html"
        >
          
            4.
          
          Quantum Algorithms for Applications
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-applications/vqe-molecules.html"
                >
                  
                    4.1
                  
                  Simulating Molecules using VQE
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-applications/satisfiability-grover.html"
                >
                  
                    4.2
                  
                  Solving Satisfiability Problems using Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html"
        >
          
            5.
          
          Investigating Quantum Hardware Using Qiskit
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html"
                >
                  
                    5.1
                  
                  Calibrating Qubits with OpenPulse
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/error-correction-repetition-code.html"
                >
                  
                    5.2
                  
                  Introduction to Quantum Error Correction using Repetition Codes
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/measurement-error-mitigation.html"
                >
                  
                    5.3
                  
                  Measurement Error Mitigation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/randomized-benchmarking.html"
                >
                  
                    5.4
                  
                  Randomized Benchmarking
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/measuring-quantum-volume.html"
                >
                  
                    5.5
                  
                  Measuring Quantum Volume
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-paper-implementations/vqls.html"
        >
          
            6.
          
          Implementations of Recent Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-paper-implementations/vqls.html"
                >
                  
                    6.1
                  
                  Variational Quantum Linear Solver
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="https://github.com/jupyter/jupyter-book">Jupyter Book</a></p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button
      id="js-sidebar-toggle"
      class="hamburger hamburger--arrowalt is-active"
    >
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><i class="fa fa-download"></i></button>
    <div class="download-buttons">
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">PDF</button></a>
    </div>
</div>

</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title"><i class="fa fa-list"></i>   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/textbook/search.html" class="topbar-right-button" id="search-button"><i class="fa fa-search"></i></a>
</div>

      <main class="c-textbook__page" tabindex="-1">
        <div class="c-textbook__content" id="textbook_content">
          <div class="search-content__inner-wrap">
    <input type="text" id="lunr_search" class="search-input" tabindex="-1" placeholder="'Enter your search term...''" />
    <div id="results" class="results"></div>
</div>

<script>
    // Add the lunr store since we will now search it
    var store = [{
        "title": "Bernstein-Vazirani Algorithm",
        
        "excerpt":
            "Bernstein-Vazirani Algorithm In this section, we first introduce the Bernstein-Vazirani problem, and classical and quantum algorithms to solve it. We then implement the quantum algorithm using Qiskit, and run on a simulator and device. Contents Introduction Bernstein-Vazirani Problem Bernstein-Vazirani Algorithm Example Qiskit Implementation Simulation Device Problems References 1. Introduction The Bernstein-Vazirani algorithm, first introduced in Reference [1], can be seen as an extension of the Deutsch-Josza algorithm covered in the last section. It showed that there can be advantages in using a quantum computer as a computational tool for more complex problems compared to the Deutsch-Josza problem. 1a. Bernstein-Vazirani Problem...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html",
        "teaser":null},{
        "title": "Deutsch-Josza Algorithm",
        
        "excerpt":
            "Deutsch-Josza Algorithm In this section, we first introduce the Deutsch-Josza problem, and classical and quantum algorithms to solve it. We then implement the quantum algorithm using Qiskit, and run on a simulator and device. Contents Introduction Deutsch-Josza Problem Deutsch-Josza Algorithm Example Qiskit Implementation Simulation Device Problems References 1. Introduction The Deutsch-Josza algorithm, first introduced in Reference [1], was the first example of a quantum algorithm that performs better than the best classical algorithm. It showed that there can be advantages in using a quantum computer as a computational tool for a specific problem. 1a. Deutsch-Josza Problem We are given a...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/deutsch-josza.html",
        "teaser":null},{
        "title": "Grover's Algorithm",
        
        "excerpt":
            "Grover's Algorithm In this section, we introduce Grover's algorithm and how it can be used to solve unstructured search problems. We then implement the quantum algorithm using Qiskit, and run on a simulator and device. Contents Introduction Example: 2 Qubits Simulation Device Example: 3 Qubits Simulation Device Problems References 1. Introduction You have likely heard that one of the many advantages a quantum computer has over a classical computer is its superior speed searching databases. Grover's algorithm demonstrates this capability. This algorithm can speed up an unstructured search problem quadratically, but its uses extend beyond that; it can serve as...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/grover.html",
        "teaser":null},{
        "title": "Quantum Fourier Transform",
        
        "excerpt":
            "Quantum Fourier Transform In this tutorial, we introduce the quantum fourier transform (QFT), derive the circuit, and implement it using Qiskit. We show how to run QFT on a simulator and a five qubit device. Contents Introduction Example 1: 1-qubit QFT The Quantum Fourier transform The circuit that implements QFT Example 2: 3-qubit QFT A note about the form of the QFT circuit Qiskit Implementation Running QFT on a simulator Running QFT on a real quantum device Problems References 1. Introduction The Fourier transform occurs in many different versions throughout classical computing, in areas ranging from signal processing to data...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html",
        "teaser":null},{
        "title": "Quantum Phase Estimation",
        
        "excerpt":
            "Quantum Phase Estimation Quantum phase estimation is one of the most important subroutines in quantum computation. It serves as a central building block for many quantum algorithms. The objective of the algorithm is the following: Given a unitary operator $U$, the algorithm estimates $\\theta$ in $U\\vert\\psi \\rangle =e^{\\boldsymbol{2\\pi i} \\theta }|\\psi \\rangle$. Here $|\\psi\\rangle$ is an eigenvector and $e^{\\boldsymbol{2\\pi i}\\theta}$ is the corresponding eigenvalue. Since $U$ is unitary, all of its eigenvalues have a norm of 1. Quantum Circuit for Phase Estimation The general quantum circuit for phase estimation is: As mentioned above, this circuit estimates the phase of a...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html",
        "teaser":null},{
        "title": "Simon's Algorithm",
        
        "excerpt":
            "Simon's Algorithm In this section, we first introduce the Simon problem, and classical and quantum algorithms to solve it. We then implement the quantum algorithm using Qiskit, and run on a simulator and device. Contents Introduction Simon's Problem Simon's Algorithm Example Qiskit Implementation Simulation Device Oracle Problems References 1. Introduction Simon's algorithm, first introduced in Reference [1], was the first quantum algorithm to show an exponential speed-up versus the best classical algorithm in solving a specific problem. This inspired the quantum algorithm for the discrete Fourier transform, also known as quantum Fourier transform, which is used in the most famous...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/simon.html",
        "teaser":null},{
        "title": "Quantum Algorithms",
        
        "excerpt":
            "Quantum Teleportation This notebook demonstrates quantum teleportation. We first use Qiskit's built-in simulator to test our quantum circuit, and then try it out on a real quantum computer. The concept Alice wants to send quantum information to Bob. Specifically, suppose she wants to send the state $\\vert\\psi\\rangle = \\alpha\\vert0\\rangle + \\beta\\vert1\\rangle$ to Bob. This entails passing on information about $\\alpha$ and $\\beta$ to Bob. There exists a theorem in quantum mechanics which states that you cannot simply make an exact copy of an unknown quantum state. This is known as the no-cloning theorem. As a result of this we can...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-algorithms/teleportation.html",
        "teaser":null},{
        "title": "Solving Satisfiability Problems using Grover's Algorithm",
        
        "excerpt":
            "Solving Satisfiability Problems using Grover's Algorithm In this section, we demonstrate how to solve satisfiability problems using the implementation of Grover's algorithm in Qiskit Aqua. Contents Introduction 3-Satisfiability Problem Qiskit Implementation Problems References 1. Introduction Grover's algorithm for unstructured search was introduced in an earlier section, with an example and implementation using Qiskit Terra. We saw that Grover search is a quantum algorithm that can be used search for correct solutions quadratically faster than its classical counterparts. Here, we are going to illustrate the use of Grover's algorithm to solve a particular combinatorial Boolean satisfiability problem. In computer science, the...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-applications/satisfiability-grover.html",
        "teaser":null},{
        "title": "Quantum Algorithms for Applications",
        
        "excerpt":
            "Simulating Molecules using VQE In this tutorial, we introduce the Variational Quantum Eigensolver (VQE), motivate its use, explain the necessary theory, and demonstrate its implementation in finding the ground state energy of molecules. Contents Introduction The Variational Method of Quantum Mechanics Mathematical Background Bounding the Ground State The Variational Quantum Eigensolver Variational Forms Simple Variational Forms Parameter Optimization Example with a Single Qubit Variational Form Structure of Common Variational Forms VQE Implementation in Qiskit Running VQE on a Statevector Simulator Running VQE on a Noisy Simulator Problems References Introduction In many applications it is important to find the minimum eigenvalue...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-applications/vqe-molecules.html",
        "teaser":null},{
        "title": "Problems",
        
        "excerpt":
            "Classical Logic Gates with Quantum Circuits from qiskit import * from qiskit.tools.visualization import plot_histogram import numpy as np Using the NOT gate (expressed as x in Qiskit), the CNOT gate (expressed as cx in Qiskit) and the Toffoli gate (expressed as ccx in Qiskit) create functions to implement the XOR, AND, NAND and OR gates. An implementation of the NOT gate is provided as an example. NOT gate This function takes a binary string input ('0' or '1') and returns the opposite binary output'. def NOT(input): q = QuantumRegister(1) # a qubit in which to encode and manipulate the input...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-ex/ex1.html",
        "teaser":null},{
        "title": "Set 2. Basic Synthesis of Single-Qubit Gates",
        
        "excerpt":
            "Basic Synthesis of Single-Qubit Gates from qiskit import * from qiskit.tools.visualization import plot_histogram import numpy as np 1 Show that the Hadamard gate can be written in the following two forms $$H = \\frac{X+Z}{\\sqrt{2}} \\equiv \\exp\\left(i \\frac{\\pi}{2} \\, \\frac{X+Z}{\\sqrt{2}}\\right).$$Here $\\equiv$ is used to denote that the equality is valid up to a global phase, and hence that the resulting gates are physically equivalent. Hint: it might even be easiest to prove that $e^{i\\frac{\\pi}{2} M} \\equiv M$ for any matrix whose eigenvalues are all $\\pm 1$, and that such matrices uniquely satisfy $M^2=I$. 2 The Hadamard can be constructed from rx...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-ex/ex2.html",
        "teaser":null},{
        "title": "Set 3. Building the Best AND Gate",
        
        "excerpt":
            "Building the Best AND Gate from qiskit import * from qiskit.tools.visualization import plot_histogram from qiskit.providers.aer import noise import numpy as np In Problem Set 1, you made an AND gate with quantum gates. This time you'll do the same again, but for a real device. Using real devices gives you two major constraints to deal with. One is the connectivity, and the other is noise. The connectivity tells you what cx gates it is possible to do perform directly. For example, the device ibmq_5_tenerife has five qubits numbered from 0 to 4. It has a connectivity defined by coupling_map =...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-ex/ex3.html",
        "teaser":null},{
        "title": "Basic Circuit Identities",
        
        "excerpt":
            "Basic Circuit Identities from qiskit import * from qiskit.circuit import Gate When we program quantum computers, our aim is always to build useful quantum circuits from the basic building blocks. But sometimes, we might not have all the basic building blocks we want. In this section, we'll look at how we can transform basic gates into each other, and how to use them to build some gates that are slightly more complex (but still pretty basic). Many of the techniques discussed in this chapter were first proposed in a paper by Barenco and coauthors in 1995 [1]. Making a controlled-$Z$...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/basic-circuit-identities.html",
        "teaser":null},{
        "title": "Fun with Matrices",
        
        "excerpt":
            "Fun with Matrices Manipulating matrices is the heart of how we analyze quantum programs. In this section we'll look at some of the most common tools that can be used for this. Unitary and Hermitian matrices Studying universality is inherently an endeavour that needs math -- so we'll need to get ourselves some mathematical tools. Firstly, we need the concept of the Hermitian conjugate. For this we take a matrix $M$ , then we replace every element with its complex conjugate, and finally we transpose them (replace the top left element with the bottom right, and so on). This gives...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/fun-matrices.html",
        "teaser":null},{
        "title": "Single Qubits and Multi-Qubits gates",
        
        "excerpt":
            "Introduction Just having some qubits is not enough: We also need to manipulate them. All possible ways of doing this can be compiled down to a basic set of operations, known as quantum gates. Typically, the gates that can be directly implemented in hardware will act only on one or two qubits. In our circuits, we may want to use complex gates that act on a great number of qubits. Fortunately, this will not be a problem. With the one and two qubit gates given to us by the hardware, it is possible to build any other gate. In this...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/introduction.html",
        "teaser":null},{
        "title": "Proving Universality",
        
        "excerpt":
            "Proving Universality What does it mean for a computer to do everything that it could possibly do? This was a question tackled by Alan Turing before we even had a good idea of what a computer was. To ask this question for our classical computers, and specifically for our standard digital computers, we need to strip away all the screens, speakers and fancy input devices. What we are left with is simply a machine that converts input bit strings into output bit strings. If a device can perform any such conversion, taking any arbitrary set of inputs and coverting them...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/proving-universality.html",
        "teaser":null},{
        "title": "Quantum Gates",
        
        "excerpt":
            "Quantum Gates from qiskit import * To manipulate an input state we need to apply the basic operations of quantum computing. These are known as quantum gates. Here we'll give an introduction to some of the most fundamental gates in quantum computing. Most of those we'll be looking at act only on a single qubit. This means that their actions can be understood in terms of the Bloch sphere. The Pauli operators The simplest quantum gates are the Paulis: $X$, $Y$ and $Z$. Their action is to perform a half rotation of the Bloch sphere around the x, y and...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/quantum-gates.html",
        "teaser":null},{
        "title": "The Standard Gate Set",
        
        "excerpt":
            "The Standard Gate Set For every possible realization of fault-tolerant quantum computing, there is a set of quantum operations that are most straightforward to realize. Often these consist of multiple so-called Clifford gates, combined with a few single-qubit gates that do not belong to the Clifford group. In this section we'll introduce these concepts, in preparation for showing that they are universal. Clifford gates Some of the most important quantum operations are the so-called Clifford operations. A prominent example is the Hadamard gate: $$ H = |+\\rangle\\langle0|~+~ |-\\rangle\\langle1| = |0\\rangle\\langle+|~+~ |1\\rangle\\langle-|. $$This gate is expressed above using outer products, as...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-gates/standard-gate-set.html",
        "teaser":null},{
        "title": "Implementations of Recent Quantum Algorithms",
        
        "excerpt":
            "The Variational Quantum Linear Solver import qiskit from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister from qiskit import Aer, execute import math import random import numpy as np from scipy.optimize import minimize Introduction The Variational Quantum Linear Solver, or the VQLS is a variational quantum algorithm that utilizes VQE in order to solve systems of linear equations more efficiently than classical computational algortihms. Specifically, if we are given some matrix $\\textbf{A}$, such that $\\textbf{A} |\\textbf{x}\\rangle \\ = \\ |\\textbf{b}\\rangle$, where $|\\textbf{b}\\rangle$ is some known vector, the VQLS algorithm is theoretically able to find a normalized $|x\\rangle$ that is proportional to $|\\textbf{x}\\rangle$, which...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-paper-implementations/vqls.html",
        "teaser":null},{
        "title": "Linear Algebra",
        
        "excerpt":
            "An Introduction to Linear Algebra for Quantum Computing from matplotlib import pyplot as plt import numpy as np from qiskit import * from qiskit.visualization import plot_bloch_vector Introduction Linear algebra is the language of quantum computing. For this reason, it is crucial to develop a good understanding of the basic mathematical concepts that are built upon in order to arrive at many of the amazing and interesting constructions seen in quantum computation! The goal of this section of the textbook is to start at the absolute basics of linear algebra: vectors and vector spaces, and build a foundation that the reader...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-prerequisites/linear_algebra.html",
        "teaser":null},{
        "title": "Prerequisites",
        
        "excerpt":
            "Introduction to Python and Jupyter notebooks Python is a programming language where you don't need to compile. You can just run it line by line (which is how we can use it in a notebook). So if you are quite new to programming, Python is a great place to start. The current version is Python 3, which is what we'll be using here. One way to code in Python is to use a Jupyter notebook. This is probably the best way to combine programming, text and images. In a notebook, everything is laid out in cells. Text cells and code...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-prerequisites/python-and-jupyter-notebooks.html",
        "teaser":null},{
        "title": "Qiskit",
        
        "excerpt":
            "Basic Qiskit Syntax Installation Qiskit is a package in Python for doing everything you'll ever need with quantum computing. If you don't have it already, you need to install it. Once it is installed, you need to import it. There are generally two steps to installing Qiskit. The first one is to install Anaconda, a python package that comes with almost all dependencies that you will ever need. Once you've done this, Qiskit can then be installed by running the command pip install qiskit in your terminal. For detailed installation instructions, refer to the documentation page here. Note: The rest...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-prerequisites/qiskit.html",
        "teaser":null},{
        "title": "Investigating Quantum Hardware Using Qiskit",
        
        "excerpt":
            "Calibrating Qubits using OpenPulse Contents Introduction Finding our qubit Rabi experiment 0 vs 1 Measuring T1 Ramsey experiment Measuring T2 Dynamical Decoupling 1. Introduction %matplotlib inline import qiskit.pulse as pulse import qiskit.pulse.pulse_lib as pulse_lib from qiskit.compiler import assemble import qiskit qiskit.__qiskit_version__ {&#39;qiskit&#39;: &#39;0.11.1&#39;, &#39;qiskit-terra&#39;: &#39;0.8.2&#39;, &#39;qiskit-ignis&#39;: &#39;0.1.1&#39;, &#39;qiskit-aer&#39;: &#39;0.2.3&#39;, &#39;qiskit-ibmq-provider&#39;: &#39;0.3.1&#39;, &#39;qiskit-aqua&#39;: &#39;0.5.3&#39;} from qiskit import IBMQ IBMQ.load_account() provider = IBMQ.get_provider(hub=&#39;your-hub-name&#39;) # change to your hub name backend = provider.get_backend(&#39;ibmq_poughkeepsie&#39;) backend_config = backend.configuration() from qiskit.tools.jupyter import backend_overview, backend_monitor %qiskit_backend_monitor backend The superconducting devices at IBM are routinely calibrated to determine the properties of each qubit. The calibration procedure determines the...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html",
        "teaser":null},{
        "title": "Introduction to Quantum Error Correction using Repetition Codes",
        
        "excerpt":
            "Introduction to Quantum Error Correction from qiskit import * Correcting errors in phone calls In this chapter, we will introduce the idea of quantum error correction. This will be done via the quantum repetition code: a simple quantum error correcting code that has all the basic features of more complex methods. Unfortunately, it is not a fully useful code in itself (which is why the more complex methods are needed). Nevertheless it is a great starting point, and a good first test of how well quantum error correction might work on a given device. Before all this, it would be...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html",
        "teaser":null},{
        "title": "Measurement Error Mitigation",
        
        "excerpt":
            "Measurement Error Mitigation from qiskit import * Introduction The effect of noise is to give us outputs that are not quite correct. The effect of noise that occurs throughout a computation will be quite complex in general, as one would have to consider how each gate transforms the effect of each error. A simpler form of noise is that occuring during final measurement. At this point, the only job remaining in the circuit is to extract a bit string as an output. For an $n$ qubit final measurement, this means extracting one of the $2^n$ possible $n$ bit strings. As...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html",
        "teaser":null},{
        "title": "Measuring Quantum Volume",
        
        "excerpt":
            "Measuring Quantum Volume Introduction Quantum Volume (QV) is a single-number metric that can be measured using a concrete protocol on near-term quantum computers of modest size. The QV method quantifies the largest random circuit of equal width and depth that the computer successfully implements. Quantum computing systems with high-fidelity operations, high connectivity, large calibrated gate sets, and circuit rewriting toolchains are expected to have higher quantum volumes. References [1] Andrew W. Cross, Lev S. Bishop, Sarah Sheldon, Paul D. Nation, and Jay M. Gambetta, Validating quantum computers using randomized model circuits, https://arxiv.org/pdf/1811.12926 The Quantum Volume Protocol A QV protocol (see...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-quantum-hardware/measuring-quantum-volume.html",
        "teaser":null},{
        "title": "Randomized Benchmarking",
        
        "excerpt":
            "Randomized Benchmarking Introduction One of the main challenges in building a quantum information processor is the non-scalability of completely characterizing the noise affecting a quantum system via process tomography. In addition, process tomography is sensitive to noise in the pre- and post rotation gates plus the measurements (SPAM errors). Gateset tomography can take these errors into account, but the scaling is even worse. A complete characterization of the noise is useful because it allows for the determination of good error-correction schemes, and thus the possibility of reliable transmission of quantum information. Since complete process tomography is infeasible for large systems,...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-quantum-hardware/randomized-benchmarking.html",
        "teaser":null},{
        "title": "The Atoms of Computation",
        
        "excerpt":
            "The Atoms of Computation Programming a quantum computer is now something that anyone can do in the comfort of their own home. But what to create? What is a quantum program anyway? In fact, what is a quantum computer? These questions can be answered by making comparisons to standard digital computers. Unfortunately, most people don’t actually understand how digital computers work either. So in this article we’ll look at the basics principles behind these devices. To help us transition over to quantum computing later on, we’ll do it using the same tools as we'll use for quantum. from qiskit import...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/atoms-computation.html",
        "teaser":null},{
        "title": "Quantum States and Qubits",
        
        "excerpt":
            "Introduction If you think quantum mechanics sounds challenging, you are not alone. All of our intuitions are based on day-to-day experiences, and so are better at understanding the behavior of balls and bananas than atoms or electrons. Though quantum objects can seem random and chaotic at first, they just follow a different set of rules. Once we know what those rules are, we can use them to create new and powerful technology. Quantum computing will be the most revolutionary example of this. To get you started on your journey towards quantum computing, let's test what you already know. Which of...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/introduction.html",
        "teaser":null},{
        "title": "Pauli Matrices and the Bloch Sphere",
        
        "excerpt":
            "Pauli Matrices and the Bloch Sphere from qiskit import * from qiskit.visualization import plot_bloch_vector In this section we'll further develop the topics introduced in the last, and introduce a useful visualization of single-qubit states. Pauli matrices Wherever there are vectors, matrices are not far behind. The three important matrices for qubits are known as the Pauli matrices. $$ X= \\begin{pmatrix} 0&amp;1 \\\\\\\\ 1&amp;0 \\end{pmatrix}\\\\\\\\ Y= \\begin{pmatrix} 0&amp;-i \\\\\\\\ i&amp;0 \\end{pmatrix}\\\\\\\\ Z= \\begin{pmatrix} 1&amp;0 \\\\\\\\ 0&amp;-1 \\end{pmatrix} $$These have many useful properties, as well as a deep connection to the x, y and z measurements. Specifically, we can use them to...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/pauli-matrices-bloch-sphere.html",
        "teaser":null},{
        "title": "States for Many Qubits",
        
        "excerpt":
            "States for Many Qubits from qiskit import * Introduction We've already seen how to write down the state of a single qubit. Now we can look at how to do it when we have more than just one. Let's start by looking at bits. The state of a single bit is expressed as 0 or 1. For two bits we can have 00, 01, 10 or 11, where each digit tells us the state of one of the bits. For more bits, we just use longer strings of bit values, known as 'bit strings'. The conversion to qubits is quite...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/states-many-qubits.html",
        "teaser":null},{
        "title": "The Unique Properties of Qubits",
        
        "excerpt":
            "The Unique Properties of Qubits from qiskit import * from qiskit.visualization import plot_histogram You now know something about bits, and about how our familiar digital computers work. All the complex variables, objects and data structures used in modern software are basically all just big piles of bits. Those of us who work on quantum computing call these classical variables. The computers that use them, like the one you are using to read this article, we call classical computers. In quantum computers, our basic variable is the qubit: a quantum variant of the bit. These are quantum objects, obeying the laws...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/unique-properties-qubits.html",
        "teaser":null},{
        "title": "Writing Down Qubit States",
        
        "excerpt":
            "Writing Down Qubit States from qiskit import * In the previous chapter we saw that there are multiple ways to extract an output from a qubit. The two methods we've used so far are the z and x measurements. # z measurement of qubit 0 measure_z = QuantumCircuit(1,1) measure_z.measure(0,0); # x measurement of qubit 0 measure_x = QuantumCircuit(1,1) measure_x.h(0) measure_x.measure(0,0); Sometimes these measurements give results with certainty. Sometimes their outputs are random. This all depends on which of the infinitely many possible states our qubit is in. We therefore need a way to write down these states and figure out...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/ch-states/writing-down-qubit-states.html",
        "teaser":null},{
        "title": "Preface",
        
        "excerpt":
            "Learn Quantum Computing using Qiskit Greetings from the Qiskit Community team! We initiated this open-source textbook in collaboration with IBM Research as a university quantum algorithms/computation course supplement based on Qiskit. The goal of the textbook is to develop skills in the following areas. The mathematics behind quantum algorithms Details about today's non-fault-tolerant quantum devices Writing code in Qiskit to implement quantum algorithms on IBM's cloud quantum systems While this textbook does not attempt to be an expansive survey of the field, it does attempt to be as self-contained as possible. If you have any questions or suggestions about the...",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/preface.html",
        "teaser":null},{
        "title": "Upcoming",
        
        "excerpt":
            "                  Upcoming topics            The following topics are currently being developed for addition to the textbook.             Shor's Algorithm Overview of Quantum Algorithms for NISQ Hardware Mapping the Ising Model onto a Superconducting Quantum Computer Solving Combinatorial Optimization Problems using QAOA Solving Linear Systems of Equations using HHL Securing Communications using BB84 Decoherence and Energy Relaxation: Measuring T2 and T1 Optimizing Microwave Pulses for High-Fidelity Qubit Operations State and Process Tomography                     ",
        "categories": [],
        "tags": [],
        "url": "https://community.qiskit.org/textbook/upcoming.html",
        "teaser":null},]
</script>
        </div>
        <nav class="c-page__nav">
  

  
</nav>

        <footer>
  <p class="footer">This page was created by <a href="https://github.com/jupyter/jupyter-book/graphs/contributors">The Jupyter Book Community</a></p>
</footer>

      </main>
    </div>
  </body>
</html>
