<!DOCTYPE html>
<html lang="en">
  

  <script>
(function () {
  'use strict'
  window.digitalData = {
    page: {
      pageInfo: {
        productTitle: 'IBM Q Experience',
        analytics: {
          category: 'Qiskit.org'
        }
      }
    }
  }
  window._analytics = {
    segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw'
  }
}());
</script>
<script async src="https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js"></script>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Investigating Quantum Hardware Using Qiskit</title>
  <meta name="description" content="            Calibrating qubits using Qiskit and OpenPulse Qiskit is an open-source framework for programming quantum computers (Ref. 1). Using Qiskit, quantu...">

  <link rel="canonical" href="https://community.qiskit.orgtextbook/ch-quantum-hardware/calibrating-qubits-openpulse.html">
  <link rel="alternate" type="application/rss+xml" title="Qiskit Textbook" href="https://community.qiskit.orgtextbook/feed.xml">

  <meta property="og:url"         content="https://community.qiskit.orgtextbook/ch-quantum-hardware/calibrating-qubits-openpulse.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Investigating Quantum Hardware Using Qiskit" />
<meta property="og:description" content="            Calibrating qubits using Qiskit and OpenPulse Qiskit is an open-source framework for programming quantum computers (Ref. 1). Using Qiskit, quantu..." />
<meta property="og:image"       content="https://community.qiskit.org/textbook/images/logo/logo.png" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://community.qiskit.orgtextbook/ch-quantum-hardware/calibrating-qubits-openpulse.html",
  "headline": "Investigating Quantum Hardware Using Qiskit",
  "datePublished": "2019-12-11T21:28:08+00:00",
  "dateModified": "2019-12-11T21:28:08+00:00",
  "description": "            Calibrating qubits using Qiskit and OpenPulse Qiskit is an open-source framework for programming quantum computers (Ref. 1). Using Qiskit, quantu...",
  "author": {
    "@type": "Person",
    "name": "The Qiskit Team"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://community.qiskit.orgtextbook",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://community.qiskit.orgtextbook",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/textbook/assets/css/styles.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css ">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/textbook/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>

  <!-- DOM updating function -->
  <script>
const runWhenDOMLoaded = cb => {
  if (document.readyState != 'loading') {
    cb()
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', cb)
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') cb()
    })
  }
}

// Helper function to init things quickly
initFunction = function(myfunc) {
  runWhenDOMLoaded(myfunc);
  document.addEventListener('turbolinks:load', myfunc);
};
</script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = 'textbook';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script>
const initAnchors = () => {
  if (window.anchors === undefined) {
    setTimeout(initAnchors, 250)
    return
  }
  anchors.add("main h1, main h2, main h3, main h4")
}

initFunction(initAnchors);
</script>


  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Selectors for elements on the page -->
  <script>
/**
 * Select various elements on the page for later use
 */

// IDs we'll attach to cells
const codeCellId = index => `codecell${index}`
const inputCellId = index => `inputcell${index}`

pageElements = {}

// All code cells
findCodeCells = function() {
    var codeCells = document.querySelectorAll('div.c-textbook__content > div.highlighter-rouge > div.highlight > pre, div.input_area pre, div.text_cell_render div.highlight pre')
    pageElements['codeCells'] = codeCells;

    codeCells.forEach((codeCell, index) => {
      const id = codeCellId(index)
      codeCell.setAttribute('id', id)
    })
};

initFunction(findCodeCells);

// All cells in general
findInputCells = function() {
    var inputCells = document.querySelectorAll('div.jb_cell')
    pageElements['inputCells'] = inputCells;

    inputCells.forEach((inputCell, index) => {
        const id = inputCellId(index)
        inputCell.setAttribute('id', id)
    })
};

initFunction(findInputCells);
</script>

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->



  <!-- Load the auto-generating TOC -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js" async></script>
<script>
const initToc = () => {
  if (window.tocbot === undefined) {
    setTimeout(initToc, 250)
    return
  }

  // Check whether we have any sidebar content. If not, then show the sidebar earlier.
  var SIDEBAR_CONTENT_TAGS = ['.tag_full_width', '.tag_popout'];
  var sidebar_content_query = SIDEBAR_CONTENT_TAGS.join(', ')
  if (document.querySelectorAll(sidebar_content_query).length === 0) {
    document.querySelector('nav.onthispage').classList.add('no_sidebar_content')
  }

  // Initialize the TOC bot
  tocbot.init({
    tocSelector: 'nav.onthispage',
    contentSelector: '.c-textbook__content',
    headingSelector: 'h2, h3',
    orderedList: false,
    collapseDepth: 6,
    listClass: 'toc__menu',
    activeListItemClass: "",  // Not using
    activeLinkClass: "", // Not using
  });

}
initFunction(initToc);
</script>


  <!-- Google analytics -->
  <script src="/textbook/assets/js/ga.js" async></script>

  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/textbook/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/textbook/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/textbook/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  

  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script>
/**
 * Set up copy/paste for code blocks
 */
const clipboardButton = id =>
  `<a id="copy-button-${id}" class="btn copybtn o-tooltip--left" data-tooltip="Copy" data-clipboard-target="#${id}">
    <img src="/textbook/assets/images/copy-button.svg" alt="Copy to clipboard">
  </a>`

// Clears selected text since ClipboardJS will select the text when copying
const clearSelection = () => {
  if (window.getSelection) {
    window.getSelection().removeAllRanges()
  } else if (document.selection) {
    document.selection.empty()
  }
}

// Changes tooltip text for two seconds, then changes it back
const temporarilyChangeTooltip = (el, newText) => {
  const oldText = el.getAttribute('data-tooltip')
  el.setAttribute('data-tooltip', newText)
  setTimeout(() => el.setAttribute('data-tooltip', oldText), 2000)
}

const addCopyButtonToCodeCells = () => {
  // If ClipboardJS hasn't loaded, wait a bit and try again. This
  // happens because we load ClipboardJS asynchronously.
  if (window.ClipboardJS === undefined) {
    setTimeout(addCopyButtonToCodeCells, 250)
    return
  }

  pageElements['codeCells'].forEach((codeCell) => {
    const id = codeCell.getAttribute('id')
    if (document.getElementById("copy-button" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', clipboardButton(id));
    }
  })

  const clipboard = new ClipboardJS('.copybtn')
  clipboard.on('success', event => {
    clearSelection()
    temporarilyChangeTooltip(event.trigger, 'Copied!')
  })

  clipboard.on('error', event => {
    temporarilyChangeTooltip(event.trigger, 'Failed to copy')
  })

  // Get rid of clipboard before the next page visit to avoid memory leak
  document.addEventListener('turbolinks:before-visit', () =>
    clipboard.destroy()
  )
}

initFunction(addCopyButtonToCodeCells);
</script>


  <!-- Hide cell code -->
  <script>
    /**
    Add buttons to hide code cells
    */


    var setCodeCellVisibility = function (inputField, kind) {
        // Update the image and class for hidden
        var id = inputField.getAttribute('data-id');
        var codeCell = document.querySelector(`#${id} div.highlight`);

        if (kind === "visible") {
            codeCell.classList.remove('hidden');
            inputField.checked = true;
        } else {
            codeCell.classList.add('hidden');
            inputField.checked = false;
        }
    }

    var toggleCodeCellVisibility = function (event) {
        // The label is clicked, and now we decide what to do based on the input field's clicked status
        if (event.target.tagName === "LABEL") {
            var inputField = event.target.previousElementSibling;
        } else {
            // It is the span inside the target
            var inputField = event.target.parentElement.previousElementSibling;
        }

        if (inputField.checked === true) {
            setCodeCellVisibility(inputField, "visible");
        } else {
            setCodeCellVisibility(inputField, "hidden");
        }
    }


    // Button constructor
    const hideCodeButton = id => `<input class="hidebtn" type="checkbox" id="hidebtn${id}" data-id="${id}"><label title="Toggle cell" for="hidebtn${id}" class="plusminus"><span class="pm_h"></span><span class="pm_v"></span></label>`

    var addHideButton = function () {
        // If a hide button is already added, don't add another
        if (document.querySelector('div.tag_hide_input input') !== null) {
            return;
        }

        // Find the input cells and add a hide button
        pageElements['inputCells'].forEach(function (inputCell) {
            if (!inputCell.classList.contains("tag_hide_input")) {
                // Skip the cell if it doesn't have a hidecode class
                return;
            }

            const id = inputCell.getAttribute('id')

            // Insert the button just inside the end of the next div
            inputCell.querySelector('div.input').insertAdjacentHTML('beforeend', hideCodeButton(id))

            // Set up the visibility toggle
            hideLink = document.querySelector(`#${id} div.inner_cell + input + label`);
            hideLink.addEventListener('click', toggleCodeCellVisibility)
        });
    }


    // Initialize the hide buttos
    var initHiddenCells = function () {
        // Add hide buttons to the cells
        addHideButton();

        // Toggle the code cells that should be hidden
        document.querySelectorAll('div.tag_hide_input input').forEach(function (item) {
            setCodeCellVisibility(item, 'hidden');
            item.checked = true;
        })
    }

    initFunction(initHiddenCells);

</script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/textbook/assets/css/styles.css",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://delapuente.github.io/qiskit-textbook"><img src="/textbook/images/logo/logo.png" class="textbook_logo" id="sidebar-logo" data-turbolinks-permanent/></a>
  <h2 class="c-sidebar__title">Qiskit Textbook</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/preface.html"
        >
          
          Preface
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/upcoming.html"
        >
          
          Upcoming
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-prerequisites/python-and-jupyter-notebooks.html"
        >
          
            0.
          
          Prerequisites
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/python-and-jupyter-notebooks.html"
                >
                  
                    0.1
                  
                  Python and Jupyter Notebooks
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/qiskit.html"
                >
                  
                    0.2
                  
                  Qiskit
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-prerequisites/linear_algebra.html"
                >
                  
                    0.3
                  
                  Linear Algebra
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-states/introduction.html"
        >
          
            1.
          
          Quantum States and Qubits
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/introduction.html"
                >
                  
                    1.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/atoms-computation.html"
                >
                  
                    1.2
                  
                  The Atoms of Computation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/unique-properties-qubits.html"
                >
                  
                    1.3
                  
                  The Unique Properties of Qubits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/writing-down-qubit-states.html"
                >
                  
                    1.4
                  
                  Writing Down Qubit States
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/pauli-matrices-bloch-sphere.html"
                >
                  
                    1.5
                  
                  Pauli Matrices and the Bloch Sphere
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-states/states-many-qubits.html"
                >
                  
                    1.6
                  
                  States for Many Qubits
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-gates/introduction.html"
        >
          
            2.
          
          Single Qubits and Multi-Qubits gates
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/introduction.html"
                >
                  
                    2.1
                  
                  Introduction
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/quantum-gates.html"
                >
                  
                    2.2
                  
                  Quantum Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/fun-matrices.html"
                >
                  
                    2.3
                  
                  Fun with Matrices
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/standard-gate-set.html"
                >
                  
                    2.4
                  
                  The Standard Gate Set
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/proving-universality.html"
                >
                  
                    2.5
                  
                  Proving Universality
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-gates/basic-circuit-identities.html"
                >
                  
                    2.6
                  
                  Basic Circuit Identities
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-ex/ex1.html"
        >
          
          Problems
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex1.html"
                >
                  
                  Set 1. Classical Logic Gates with Quantum Circuits
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex2.html"
                >
                  
                  Set 2. Basic Synthesis of Single-Qubit Gates
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-ex/ex3.html"
                >
                  
                  Set 3. Building the Best AND Gate
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-algorithms/teleportation.html"
        >
          
            3.
          
          Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/teleportation.html"
                >
                  
                    3.1
                  
                  Quantum Teleportation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/deutsch-josza.html"
                >
                  
                    3.2
                  
                  Deutsch-Josza Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/bernstein-vazirani.html"
                >
                  
                    3.3
                  
                  Bernstein-Vazirani Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/simon.html"
                >
                  
                    3.4
                  
                  Simon's Algorithm
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/quantum-fourier-transform.html"
                >
                  
                    3.5
                  
                  Quantum Fourier Transform
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/quantum-phase-estimation.html"
                >
                  
                    3.6
                  
                  Quantum Phase Estimation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-algorithms/grover.html"
                >
                  
                    3.7
                  
                  Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-applications/vqe-molecules.html"
        >
          
            4.
          
          Quantum Algorithms for Applications
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-applications/vqe-molecules.html"
                >
                  
                    4.1
                  
                  Simulating Molecules using VQE
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-applications/qaoa.html"
                >
                  
                    4.2
                  
                  Solving combinatorial optimization problems using QAOA
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-applications/satisfiability-grover.html"
                >
                  
                    4.3
                  
                  Solving Satisfiability Problems using Grover's Algorithm
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry c-sidebar__entry--active"
          href="/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html"
        >
          
            5.
          
          Investigating Quantum Hardware Using Qiskit
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry c-sidebar__entry--active"
                  href="/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html"
                >
                  
                    5.1
                  
                  Calibrating Qubits with OpenPulse
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/error-correction-repetition-code.html"
                >
                  
                    5.2
                  
                  Introduction to Quantum Error Correction using Repetition Codes
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/measurement-error-mitigation.html"
                >
                  
                    5.3
                  
                  Measurement Error Mitigation
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/randomized-benchmarking.html"
                >
                  
                    5.4
                  
                  Randomized Benchmarking
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-quantum-hardware/measuring-quantum-volume.html"
                >
                  
                    5.5
                  
                  Measuring Quantum Volume
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/textbook/ch-paper-implementations/vqls.html"
        >
          
            6.
          
          Implementations of Recent Quantum Algorithms
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/textbook/ch-paper-implementations/vqls.html"
                >
                  
                    6.1
                  
                  Variational Quantum Linear Solver
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="https://github.com/jupyter/jupyter-book">Jupyter Book</a></p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button
      id="js-sidebar-toggle"
      class="hamburger hamburger--arrowalt is-active"
    >
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><i class="fa fa-download"></i></button>
    <div class="download-buttons">
        <a href="/textbook/content/ch-quantum-hardware/calibrating-qubits-openpulse.ipynb" download>
        <button id="interact-button-download" class="interact-button">ORIG</button>
        </a>
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">PDF</button></a>
    </div>
</div>

  
  
  
  


</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title"><i class="fa fa-list"></i>   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/textbook/search.html" class="topbar-right-button" id="search-button"><i class="fa fa-search"></i></a>
</div>

      <main class="c-textbook__page" tabindex="-1">
        <div class="c-textbook__content" id="textbook_content">
              <main class="jupyter-page">
    <div id="page-info"></div>
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Calibrating-qubits-using-Qiskit-and-OpenPulse">Calibrating qubits using Qiskit and OpenPulse<a class="anchor-link" href="#Calibrating-qubits-using-Qiskit-and-OpenPulse"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Qiskit is an open-source framework for programming quantum computers (Ref. <a href="#refs">1</a>). Using Qiskit, quantum circuits can be built, simulated and executed on quantum devices.</p>
<p>OpenPulse provides a language for specifying pulse level control (i.e. control of the continuous time dynamics of input signals) of a general quantum device independent of the specific hardware implementation (Ref. <a href="#refs">2</a>).</p>
<p>In this tutorial, we show how to implement typical single-qubit calibration and characterization experiments using Qiskit and OpenPulse. These are typically the first round of experiments that would be done in the lab immediately after a device has been fabricated and installed into a system. The presentation is pedagogical, and allows students to explore two-level-system dynamics experimentally.</p>
<p>Each experiment gives us more information about the system, which is typically used in subsequent experiments. For this reason, this notebook has to be mostly executed in order.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Contents">Contents<a class="anchor-link" href="#Contents"> </a></h2><p>Part 0. <a href="#importing">Getting started</a> <br/>
Part 1. <a href="#frequencysweep">Finding the qubit frequency using a frequency sweep</a> <br/></p>
<p>Part 2. Calibrating and using a $\pi$ pulse <br/>
  A. <a href="#rabi">Calibrating $\pi$ pulses using a Rabi experiment</a> <br/>
  B. <a href="#zerovone">Determining 0 vs 1</a> <br/>
  C. <a href="#T1">Measuring $T_1$ using inversion recovery</a></p>
<p>Part 3. Determining qubit coherence <br/>
  A. <a href="#ramsey">Measuring the qubit frequency precisely using a Ramsey experiment</a> <br/>
  B. <a href="#hahn">Measuring $T_2$ using Hahn echoes</a> <br/></p>
<p>Part 4. <a href="#refs">References</a></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="0.-Getting-started-">0. Getting started <a id="importing" /><a class="anchor-link" href="#0.-Getting-started-"> </a></h2><p>We'll first get our basic dependencies set up and ready to go. Since we want to use real, noisy devices for our calibration experiments in this notebook, we need to load our IBMQ account and set the appropriate backend.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.jupyter</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span>
<span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">get_provider</span><span class="p">(</span><span class="n">hub</span><span class="o">=</span><span class="s1">&#39;ibm-q&#39;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="s1">&#39;main&#39;</span><span class="p">)</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;ibmq_armonk&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We verify that the backend supports OpenPulse features by checking the backend configuration. The config provides us with general information about the structure of the backend setup.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">backend_config</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">backend_config</span><span class="o">.</span><span class="n">open_pulse</span><span class="p">,</span> <span class="s2">&quot;Backend doesn&#39;t support OpenPulse&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For instance, we can find the sampling time for the backend pulses within the backend configuration. This will be a very useful value to us as we build and execute our calibration routines.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">backend_config</span><span class="o">.</span><span class="n">dt</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sampling time: {dt*1e9} ns&quot;</span><span class="p">)</span>    <span class="c1"># The configuration returns dt in nanoseconds</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Sampling time: 0.2222222222222222 ns
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The backend defaults provide a starting point for how to use the backend. It contains estimates for qubit frequencies and default programs to enact basic quantum operators. We can access them with the following:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">backend_defaults</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">defaults</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Part-1">Part 1<a class="anchor-link" href="#Part-1"> </a></h1><h2 id="1.-Finding-the-qubit-frequency-using-a-frequency-sweep-">1. Finding the qubit frequency using a frequency sweep <a id="frequencysweep" /><a class="anchor-link" href="#1.-Finding-the-qubit-frequency-using-a-frequency-sweep-"> </a></h2><p>We begin by searching for the qubit frequency. The qubit frequency is the difference in energy between the ground and excited states, which we label the $\vert0\rangle$ and $\vert1\rangle$ states, respectively. This frequency will be crucial for creating pulses which enact particular quantum operators on the qubit -- the final goal of our calibration!</p>
<p>With superconducting qubits, higher energy levels are also available, but we fabricate the systems to be anharmonic so that we can control which transition we are exciting. That way, we are able to isolate two energy levels and treat each qubit as a basic two-level system, ignoring higher energy states.</p>
<p>In a typical lab setting, the qubit frequency can be found by sweeping a range of frequencies and looking for signs of absorption using a tool known as a Network Analyzer. This measurement gives a rough estimate of the qubit frequency. Later on, we will see how to do a more precise measurement using a Ramsey pulse sequence.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First, we define the frequency range that will be swept in search of the qubit. Since this can be arbitrarily broad, we restrict ourselves to a window of 40 MHz around the estimated qubit frequency in <code>backend_defaults</code>. We step the frequency in units of 1 MHz.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">GHz</span> <span class="o">=</span> <span class="mf">1.0e9</span>
<span class="n">MHz</span> <span class="o">=</span> <span class="mf">1.0e6</span>

<span class="c1"># We will find the qubit frequency for the following qubit.</span>
<span class="n">qubit</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># The sweep will be centered around the estimated qubit frequency.</span>
<span class="n">center_frequency_Hz</span> <span class="o">=</span> <span class="n">backend_defaults</span><span class="o">.</span><span class="n">qubit_freq_est</span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span>        <span class="c1"># The default frequency is given in Hz</span>
                                                                    <span class="c1"># warning: this will change in a future release</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Qubit </span><span class="si">{qubit}</span><span class="s2"> has an estimated frequency of {center_frequency_Hz / GHz} GHz.&quot;</span><span class="p">)</span>

<span class="c1"># We will sweep 40 MHz around the estimated frequency</span>
<span class="n">frequency_span_Hz</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span> <span class="n">MHz</span>
<span class="c1"># in steps of 1 MHz.</span>
<span class="n">frequency_step_Hz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">MHz</span>

<span class="c1"># We will sweep 20 MHz above and 20 MHz below the estimated frequency</span>
<span class="n">frequency_min</span> <span class="o">=</span> <span class="n">center_frequency_Hz</span> <span class="o">-</span> <span class="n">frequency_span_Hz</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">frequency_max</span> <span class="o">=</span> <span class="n">center_frequency_Hz</span> <span class="o">+</span> <span class="n">frequency_span_Hz</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1"># Construct an np array of the frequencies for our experiment</span>
<span class="n">frequencies_GHz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frequency_min</span> <span class="o">/</span> <span class="n">GHz</span><span class="p">,</span> 
                            <span class="n">frequency_max</span> <span class="o">/</span> <span class="n">GHz</span><span class="p">,</span> 
                            <span class="n">frequency_step_Hz</span> <span class="o">/</span> <span class="n">GHz</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The sweep will go from {frequency_min / GHz} GHz to {frequency_max / GHz} GHz </span><span class="se">\</span>
<span class="s2">in steps of {frequency_step_Hz / MHz} MHz.&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Qubit 0 has an estimated frequency of 4.974265348122223 GHz.
The sweep will go from 4.954265348122224 GHz to 4.994265348122224 GHz in steps of 1.0 MHz.
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, we define the pulses we will use for our experiment. We will start with the drive pulse, which is a Gaussian pulse.</p>
<p>Remember the value <code>dt</code> from earlier? All durations in pulse are given in terms of <code>dt</code>. In the next cell, we define the length of the drive pulse in terms of <code>dt</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">%</span><span class="k">16</span>))
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">pulse</span>            <span class="c1"># This is where we access all of our Pulse features!</span>
<span class="kn">from</span> <span class="nn">qiskit.pulse</span> <span class="kn">import</span> <span class="n">pulse_lib</span>  <span class="c1"># This Pulse module helps us build sampled pulses for common pulse shapes</span>


<span class="c1"># Drive pulse parameters</span>
<span class="n">drive_sigma_us</span> <span class="o">=</span> <span class="mf">0.075</span>                     <span class="c1"># This determines the actual width of the gaussian</span>
<span class="n">drive_samples_us</span> <span class="o">=</span> <span class="n">drive_sigma_us</span><span class="o">*</span><span class="mi">8</span>        <span class="c1"># This is a truncating parameter, because gaussians don&#39;t have </span>
                                           <span class="c1"># a natural finite length</span>

<span class="n">drive_sigma</span> <span class="o">=</span> <span class="n">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">drive_sigma_us</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>       <span class="c1"># The width of the gaussian in units of dt</span>
<span class="n">drive_samples</span> <span class="o">=</span> <span class="n">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">drive_samples_us</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>   <span class="c1"># The truncating parameter in units of dt</span>
<span class="n">drive_amp</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="c1"># Drive pulse samples</span>
<span class="n">drive_pulse</span> <span class="o">=</span> <span class="n">pulse_lib</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">drive_samples</span><span class="p">,</span>
                                 <span class="n">sigma</span><span class="o">=</span><span class="n">drive_sigma</span><span class="p">,</span>
                                 <span class="n">amp</span><span class="o">=</span><span class="n">drive_amp</span><span class="p">,</span>
                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;freq_sweep_excitation_pulse&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, we will create the instructions we need to measure our qubit. This actually consists of two pulses: one stimulates the readout with a Gaussian-Square pulse applied at the readout resonator frequency, and the other triggers the data acquisition instrument to acquire data for the duration of the pulse.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### Construct the measurement pulse</span>
<span class="c1"># Measurement pulse parameters</span>

<span class="n">meas_samples_us</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">meas_sigma_us</span> <span class="o">=</span> <span class="mf">0.014</span>     <span class="c1"># The width of the gaussian part of the rise and fall</span>
<span class="n">meas_risefall_us</span> <span class="o">=</span> <span class="mf">0.1</span>    <span class="c1"># and the truncating parameter: how many samples to dedicate to the risefall</span>

<span class="n">meas_samples</span> <span class="o">=</span> <span class="n">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">meas_samples_us</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
<span class="n">meas_sigma</span> <span class="o">=</span> <span class="n">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">meas_sigma_us</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>         <span class="c1"># The width of the gaussian part of the rise and fall</span>
<span class="n">meas_risefall</span> <span class="o">=</span> <span class="n">get_closest_multiple_of_16</span><span class="p">(</span><span class="n">meas_risefall_us</span> <span class="o">*</span> <span class="mf">1e-6</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>     <span class="c1"># and the truncating parameter: how many samples to dedicate to the risefall</span>

<span class="c1"># meas_samples = 12800</span>
<span class="c1"># meas_sigma = 64         # The width of the gaussian part of the rise and fall</span>
<span class="c1"># meas_risefall = 400     # and the truncating parameter: how many samples to dedicate to the risefall</span>

<span class="n">meas_amp</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="c1"># Measurement pulse samples</span>
<span class="n">meas_pulse</span> <span class="o">=</span> <span class="n">pulse_lib</span><span class="o">.</span><span class="n">gaussian_square</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">meas_samples</span><span class="p">,</span>
                                       <span class="n">sigma</span><span class="o">=</span><span class="n">meas_sigma</span><span class="p">,</span>
                                       <span class="n">amp</span><span class="o">=</span><span class="n">meas_amp</span><span class="p">,</span>
                                       <span class="n">risefall</span><span class="o">=</span><span class="n">meas_risefall</span><span class="p">,</span>
                                       <span class="n">name</span><span class="o">=</span><span class="s1">&#39;measurement_pulse&#39;</span><span class="p">)</span>

<span class="c1">### Construct the acquire pulse to trigger the acquisition</span>
<span class="c1"># Acquire pulse samples</span>
<span class="n">acq_cmd</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Acquire</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">meas_samples</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We have to check one additional thing in order to properly measure our qubits: the measurement map. This is a hardware constraint. When acquisition is done for one qubit, it is also done on other qubits. We have to respect this constraint when building our program in OpenPulse. Let's check which group of qubits our qubit is in:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Find out which group of qubits need to be acquired with this qubit</span>
<span class="n">meas_map_idx</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">measure_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">backend_config</span><span class="o">.</span><span class="n">meas_map</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">measure_group</span><span class="p">:</span>
        <span class="n">meas_map_idx</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">break</span>
<span class="k">assert</span> <span class="n">meas_map_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find qubit </span><span class="si">{qubit}</span><span class="s2"> in the meas_map!&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Lastly, we specify the channels on which we will apply our pulses. Drive, measure, and acquire channels are indexed by qubit index.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### Collect the necessary channels</span>
<span class="n">drive_chan</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">DriveChannel</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">meas_chan</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">MeasureChannel</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">acq_chan</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">AcquireChannel</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that the pulse parameters have been defined, and we have created the pulse shapes for our experiments. We can proceed to creating the pulse schedules.</p>
<p>At each frequency, we will send a drive pulse of that frequency to the qubit and measure immediately after the pulse. The pulse envelopes are independent of frequency, so we will build a reusable <code>schedule</code>, and we will specify the drive pulse frequency with a frequency configuration array.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create the base schedule</span>
<span class="c1"># Start with drive pulse acting on the drive channel</span>
<span class="n">schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Frequency sweep&#39;</span><span class="p">)</span>
<span class="n">schedule</span> <span class="o">+=</span> <span class="n">drive_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>

<span class="c1"># In a new schedule, which we will use again later, add a measurement stimulus on the</span>
<span class="c1"># measure channel pulse to trigger readout</span>
<span class="n">measure_schedule</span> <span class="o">=</span> <span class="n">meas_pulse</span><span class="p">(</span><span class="n">meas_chan</span><span class="p">)</span>
<span class="c1"># Trigger data acquisition, and store measured values into respective memory slots</span>
<span class="n">measure_schedule</span> <span class="o">+=</span> <span class="n">acq_cmd</span><span class="p">([</span><span class="n">pulse</span><span class="o">.</span><span class="n">AcquireChannel</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">backend_config</span><span class="o">.</span><span class="n">meas_map</span><span class="p">[</span><span class="n">meas_map_idx</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">MemorySlot</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">backend_config</span><span class="o">.</span><span class="n">meas_map</span><span class="p">[</span><span class="n">meas_map_idx</span><span class="p">]])</span>
<span class="c1"># The left shift `&lt;&lt;` is special syntax meaning to shift the start time of the schedule by some duration</span>
<span class="n">schedule</span> <span class="o">+=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="n">schedule</span><span class="o">.</span><span class="n">duration</span>

<span class="c1"># Create the frequency settings for the sweep</span>
<span class="n">schedule_frequencies</span> <span class="o">=</span> <span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">freq</span><span class="p">}</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">frequencies_GHz</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As a sanity check, it's always a good idea to look at the pulse schedule. This is done using <code>schedule.draw()</code> as shown below.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">schedule</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_26_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We assemble the <code>schedules</code> and <code>schedule_frequencies</code> above into a program object, called a Qobj, that can be sent to the quantum device. We request that each schedule (each point in our frequency sweep) is repeated <code>num_shots_per_frequency</code> times in order to get a good estimate of the qubit response.</p>
<p>We also specify measurement settings. <code>meas_level=0</code> returns raw data (an array of complex values per shot), <code>meas_level=1</code> returns kerneled data (one complex value per shot), and <code>meas_level=2</code> returns classified data (a 0 or 1 bit per shot). We choose <code>meas_level=1</code> to replicate what we would be working with if we were in the lab, and hadn't yet calibrated the discriminator to classify 0s and 1s. We ask for the <code>'avg'</code> of the results, rather than each shot individually.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">assemble</span>

<span class="n">num_shots_per_frequency</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">frequency_sweep_program</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span>
                                   <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> 
                                   <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                                   <span class="n">shots</span><span class="o">=</span><span class="n">num_shots_per_frequency</span><span class="p">,</span>
                                   <span class="n">schedule_los</span><span class="o">=</span><span class="n">schedule_frequencies</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally, we can run the assembled program on the backend using:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">frequency_sweep_program</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It is always a good idea to print the <code>job_id</code> for later retrieval, and to monitor the job status by using <code>job_monitor()</code></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># print(job.job_id())</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once the job is run, the results can be retrieved using:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">frequency_sweep_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span> <span class="c1"># timeout parameter set to 60 seconds</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will extract the results and plot them using <code>matplotlib</code>:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">sweep_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frequency_sweep_results</span><span class="o">.</span><span class="n">results</span><span class="p">)):</span>
    <span class="c1"># Get the results from the ith experiment</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">frequency_sweep_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="c1"># Get the results for `qubit` from this experiment</span>
    <span class="n">sweep_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">qubit</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">,</span> <span class="n">sweep_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [GHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Measured signal [a.u.]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_36_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As you can see above, the peak near the center corresponds to the location of the qubit frequency. The signal shows power-broadening, which is a signature that we are able to drive the qubit off-resonance as we get close to the center frequency. To get the value of the peak frequency, we will fit the values to a resonance response curve, which is typically a Lorentzian shape.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="k">def</span> <span class="nf">fit_function</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">init_params</span><span class="p">):</span>
    <span class="n">fitparams</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">init_params</span><span class="p">)</span>
    <span class="n">y_fit</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="o">*</span><span class="n">fitparams</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fitparams</span><span class="p">,</span> <span class="n">y_fit</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fit_params</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">,</span>
                                 <span class="n">sweep_values</span><span class="p">,</span> 
                                 <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">q_freq</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">/</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">q_freq</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">C</span><span class="p">,</span>
                                 <span class="p">[</span><span class="o">-</span><span class="mf">2e10</span><span class="p">,</span> <span class="mf">4.975</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3e10</span><span class="p">]</span> <span class="c1"># initial parameters for curve_fit</span>
                                <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">,</span> <span class="n">sweep_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">frequencies_GHz</span><span class="p">)])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [GHz]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Measured Signal [a.u.]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_40_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">A</span><span class="p">,</span> <span class="n">rough_qubit_frequency</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">fit_params</span>
<span class="n">rough_qubit_frequency</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">rough_qubit_frequency</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We&#39;ve updated our qubit frequency estimate from &quot;</span>
      <span class="sa">f</span><span class="s2">&quot;{round(backend_defaults.qubit_freq_est[qubit] / GHz, 5)} GHz to </span><span class="si">{rough_qubit_frequency}</span><span class="s2"> GHz.&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>We&#39;ve updated our qubit frequency estimate from 4.97427 GHz to 4.97435 GHz.
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Part-2.-Calibrating-and-using-a-$\pi$-pulse">Part 2. Calibrating and using a $\pi$ pulse<a class="anchor-link" href="#Part-2.-Calibrating-and-using-a-$\pi$-pulse"> </a></h1><h2 id="A.-Calibrating-$\pi$-pulses-using-a-Rabi-experiment-">A. Calibrating $\pi$ pulses using a Rabi experiment <a id="rabi" /><a class="anchor-link" href="#A.-Calibrating-$\pi$-pulses-using-a-Rabi-experiment-"> </a></h2><p>Once we know the frequency of our qubit, the next step is to determine the strength of a $\pi$ pulse. Strictly speaking of the qubit as a two-level system, a $\pi$ pulse is one that takes the qubit from $\vert0\rangle$ to $\vert1\rangle$, and vice versa. This is also called the $X$ or $X180$ gate, or bit-flip operator. We already know the microwave frequency needed to drive this transition from the previous frequency sweep experiment, and we now seek the amplitude needed to achieve a $\pi$ rotation from $\vert0\rangle$ to $\vert1\rangle$. The desired rotation is shown on the Bloch sphere in the figure below -- you can see that the $\pi$ pulse gets its name from the angle it sweeps over on a Bloch sphere.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://github.com/aasfaw/qiskit-intros/blob/master/zero_to_one_X180.png?raw=true"></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will change the drive amplitude in small increments and measuring the state of the qubit each time. We expect to see oscillations which are commonly named Rabi oscillations, as the qubit goes from $\vert0\rangle$ to $\vert1\rangle$ and back.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># This experiment uses these values from the previous experiment:</span>
    <span class="c1"># `qubit`,</span>
    <span class="c1"># `measure_schedule`, and</span>
    <span class="c1"># `rough_qubit_frequency`.</span>

<span class="c1"># Rabi experiment parameters</span>
<span class="n">num_rabi_points</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Drive amplitude values to iterate over: 64 amplitudes evenly spaced from 0 to 0.1</span>
<span class="n">drive_amp_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">drive_amp_max</span> <span class="o">=</span> <span class="mf">0.75</span>
<span class="n">drive_amps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">drive_amp_min</span><span class="p">,</span> <span class="n">drive_amp_max</span><span class="p">,</span> <span class="n">num_rabi_points</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Build the Rabi experiments:</span>
<span class="c1">#    A drive pulse at the qubit frequency, followed by a measurement,</span>
<span class="c1">#    where we vary the drive amplitude each time.</span>
<span class="n">rabi_schedules</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">drive_amp</span> <span class="ow">in</span> <span class="n">drive_amps</span><span class="p">:</span>
    <span class="n">rabi_pulse</span> <span class="o">=</span> <span class="n">pulse_lib</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">drive_samples</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="n">drive_amp</span><span class="p">,</span> 
                                    <span class="n">sigma</span><span class="o">=</span><span class="n">drive_sigma</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Rabi drive amplitude = </span><span class="si">{drive_amp}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Rabi drive amplitude = </span><span class="si">{drive_amp}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">+=</span> <span class="n">rabi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>
    <span class="c1"># Reuse the measure_schedule from the frequency sweep experiment</span>
    <span class="n">this_schedule</span> <span class="o">+=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span>
    <span class="n">rabi_schedules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_schedule</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The schedule will look essentially the same as the frequency sweep experiment. The only difference is that we are running a set of experiments which vary the amplitude of the drive pulse, rather than its modulation frequency.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rabi_schedules</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_48_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Assemble the schedules into a Qobj</span>
<span class="n">num_shots_per_point</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="n">rabi_experiment_program</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">rabi_schedules</span><span class="p">,</span>
                                   <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                                   <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                                   <span class="n">shots</span><span class="o">=</span><span class="n">num_shots_per_point</span><span class="p">,</span>
                                   <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">rough_qubit_frequency</span><span class="p">}]</span>
                                                <span class="o">*</span> <span class="n">num_rabi_points</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">rabi_experiment_program</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rabi_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have our results, we will extract them and fit them to a sinusoidal curve. For the range of drive amplitudes we selected, we expect that we will rotate the qubit several times completely around the Bloch sphere, starting from $|0\rangle$. The amplitude of this sinusoid tells us the fraction of the shots at that Rabi drive amplitude which yielded the $|1\rangle$ state.  We want to find the first amplitude for which that fraction state reaches a maximum -- that is the calibrated amplitude that enacts a $\pi$ pulse.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">baseline_remove</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rabi_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rabi_points</span><span class="p">):</span>
    <span class="c1"># Get the results for `qubit` from the ith experiment</span>
    <span class="n">rabi_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rabi_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">qubit</span><span class="p">])</span>

<span class="n">rabi_values</span> <span class="o">=</span> <span class="n">baseline_remove</span><span class="p">(</span><span class="n">rabi_values</span><span class="p">)</span>    

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Drive amp [a.u.]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Measured signal [a.u.]&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">drive_amps</span><span class="p">,</span> <span class="n">rabi_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mf">0.215</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mf">0.445</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.445</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mf">0.215</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;&lt;-&gt;&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;$\pi$&quot;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1e10</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_54_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fit_params</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">drive_amps</span><span class="p">,</span>
                                 <span class="n">rabi_values</span><span class="p">,</span> 
                                 <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">drive_period</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">drive_period</span> <span class="o">-</span> <span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span><span class="p">),</span>
                                 <span class="p">[</span><span class="mf">1.5e10</span><span class="p">,</span> <span class="mf">0.1e10</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">drive_amps</span><span class="p">,</span> <span class="n">rabi_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">drive_amps</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Drive amp [a.u.]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Measured signal [a.u.]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_55_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">drive_period</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">fit_params</span>
<span class="n">pi_amp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">drive_period</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pi Amplitude = </span><span class="si">{pi_amp}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Pi Amplitude = 0.23060434214516984
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Our-$\pi$-pulse!">Our $\pi$ pulse!<a class="anchor-link" href="#Our-$\pi$-pulse!"> </a></h3><p>Let's define our pulse, with the amplitude we just found, so we can use it in later experiments.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pi_pulse</span> <span class="o">=</span> <span class="n">pulse_lib</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">drive_samples</span><span class="p">,</span>
                              <span class="n">amp</span><span class="o">=</span><span class="n">pi_amp</span><span class="p">,</span> 
                              <span class="n">sigma</span><span class="o">=</span><span class="n">drive_sigma</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="s1">&#39;pi_pulse&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="B.-Determining-0-vs-1-">B. Determining 0 vs 1 <a id="zerovone" /><a class="anchor-link" href="#B.-Determining-0-vs-1-"> </a></h2>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once our $\pi$ pulses have been calibrated, we can now create the state $\vert1\rangle$ with good probability. We can use this to find out what the states $\vert0\rangle$ and $\vert1\rangle$ look like in our measurements, by repeatedly preparing them and plotting the measured signal. This is what we use to build a discriminator, which is simply a function which takes a measured and kerneled complex value and classifies it as a 0 or a 1.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create two schedules</span>

<span class="c1"># Ground state schedule</span>
<span class="n">gnd_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;ground state&quot;</span><span class="p">)</span>
<span class="n">gnd_schedule</span> <span class="o">+=</span> <span class="n">measure_schedule</span>

<span class="c1"># Excited state schedule</span>
<span class="n">exc_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;excited state&quot;</span><span class="p">)</span>
<span class="n">exc_schedule</span> <span class="o">+=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>  <span class="c1"># We found this in Part 2A above</span>
<span class="n">exc_schedule</span> <span class="o">+=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="n">exc_schedule</span><span class="o">.</span><span class="n">duration</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gnd_schedule</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_62_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">exc_schedule</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_63_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We assemble the ground and excited state preparation schedules into one Qobj. Each of these will run <code>num_shots</code> times. We choose <code>meas_level=1</code> this time, because we do not want the results already classified for us as $|0\rangle$ or $|1\rangle$. Instead, we want kerneled data: raw acquired data that has gone through a kernel function to yield a single complex value for each shot. (You can think of a kernel as a dot product applied to the raw measurement data.)
We pass the same frequency for both schedules, although it is only used by the <code>exc_schedule</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Execution settings</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="n">gnd_exc_program</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">([</span><span class="n">gnd_schedule</span><span class="p">,</span> <span class="n">exc_schedule</span><span class="p">],</span>
                           <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                           <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>
                           <span class="n">shots</span><span class="o">=</span><span class="n">num_shots</span><span class="p">,</span>
                           <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">rough_qubit_frequency</span><span class="p">}]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gnd_exc_program</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gnd_exc_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the results, we can visualize the two populations which we have prepared on a simple scatter plot, showing results from the ground state program in blue and results from the excited state preparation program in red.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gnd_results</span> <span class="o">=</span> <span class="n">gnd_exc_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:,</span> <span class="n">qubit</span><span class="p">]</span>
<span class="n">exc_results</span> <span class="o">=</span> <span class="n">gnd_exc_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">qubit</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="c1"># Plot all the results</span>
<span class="c1"># All results from the gnd_schedule are plotted in blue</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">gnd_results</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">gnd_results</span><span class="p">),</span> 
                <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;state_0&#39;</span><span class="p">)</span>
<span class="c1"># All results from the exc_schedule are plotted in red</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">exc_results</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">exc_results</span><span class="p">),</span> 
                <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;state_1&#39;</span><span class="p">)</span>

<span class="c1"># Plot a large dot for the average result of the 0 and 1 states.</span>
<span class="n">mean_gnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">gnd_results</span><span class="p">)</span> <span class="c1"># takes mean of both real and imaginary parts</span>
<span class="n">mean_exc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">exc_results</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mean_gnd</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mean_gnd</span><span class="p">),</span> 
            <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;state_0_mean&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mean_exc</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mean_exc</span><span class="p">),</span> 
            <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;state_1_mean&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;I [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Q [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;0-1 discrimination&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_69_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can clearly see that the two populations of $|0\rangle$ and $|1\rangle$ form their own clusters. Kerneled measurement results (from <code>meas_level=1</code>) are classified (into <code>meas_level=2</code>) by applying a discriminator which optimally separates these two clusters. Optimal separation is simply a line in the IQ plane, equidistant from the average results we plotted above in the large dot, and normal to the line connecting the two dots.</p>
<p>We can set up a quick classifier function by returning 0 if a given point is closer to the mean of the ground state results, and returning 1 if the point is closer to the average excited state results.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">classify</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="nb">complex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Classify the given state as |0&gt; or |1&gt;.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">mean_exc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">mean_gnd</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="C.-Measuring-$T_1$-using-inversion-recovery-">C. Measuring $T_1$ using inversion recovery <a id="T1" /><a class="anchor-link" href="#C.-Measuring-$T_1$-using-inversion-recovery-"> </a></h2><p>The $T_1$ time of a qubit is the time it takes for a qubit to decay from the excited state to the ground state. It is important because it limits the duration of meaningful programs we can run on the quantum computer.</p>
<p>Measuring $T_1$ is similar to our previous experiments, and uses the $\pi$ pulse we've calibrated. We again apply a single drive pulse, our $\pi$ pulse, then apply a measure pulse. However, this time we do not apply the measurement immediately. We insert a delay, and vary that delay between experiments. When we plot the measured signal against delay time, we will see a signal that decays exponentially as the qubit relaxes in energy. The decay time is the $T_1$, or relaxation time, of the qubit!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># T1 experiment parameters</span>
<span class="n">time_max_us</span> <span class="o">=</span> <span class="mi">450</span>
<span class="n">time_step_us</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">times_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_max_us</span><span class="p">,</span> <span class="n">time_step_us</span><span class="p">)</span>
<span class="c1"># Convert to ns first (1 us = 1000 ns) and then convert to units of dt</span>
<span class="n">delay_times_dt</span> <span class="o">=</span> <span class="n">times_us</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">dt</span>
<span class="c1"># We will use the same `pi_pulse` and qubit frequency that we calibrated and used before</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create schedules for the experiment </span>
<span class="n">t1_schedules</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">delay</span> <span class="ow">in</span> <span class="n">delay_times_dt</span><span class="p">:</span>
    <span class="n">this_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T1 delay = </span><span class="si">{delay}</span><span class="s2"> us&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">+=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="n">t1_schedules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_schedule</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can check out our $T_1$ schedule, too. To really get a sense of this experiment, try looking at a couple of the schedules by running the next cell multiple times, with different values of <code>sched_idx</code>. You will see the measurement pulse start later as you increase <code>sched_idx</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sched_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">t1_schedules</span><span class="p">[</span><span class="n">sched_idx</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_76_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Execution settings</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">256</span>

<span class="n">t1_experiment</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t1_schedules</span><span class="p">,</span>
                         <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> 
                         <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                         <span class="n">shots</span><span class="o">=</span><span class="n">num_shots</span><span class="p">,</span>
                         <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">rough_qubit_frequency</span><span class="p">}]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1_schedules</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">t1_experiment</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t1_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t1_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_us</span><span class="p">)):</span>
    <span class="n">t1_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t1_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">qubit</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">t1_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$T_1$ Experiment&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay before measurement [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_80_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can then fit the data to a decaying exponential, giving us T1!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Fit the data</span>
<span class="n">fit_params</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">t1_values</span><span class="p">,</span> 
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T1</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">T1</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="p">),</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">3e10</span><span class="p">,</span> <span class="mf">3e10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
            <span class="p">)</span>

<span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">fit_params</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">t1_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T1 = </span><span class="si">{T1:.2f}</span><span class="s2"> us&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times_us</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;$T_1$ Experiment&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay before measurement [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_82_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Part-3.-Determining-qubit-coherence">Part 3. Determining qubit coherence<a class="anchor-link" href="#Part-3.-Determining-qubit-coherence"> </a></h1><h2 id="A.-Measuring-the-qubit-frequency-precisely-using-a-Ramsey-experiment-">A. Measuring the qubit frequency precisely using a Ramsey experiment <a id="ramsey" /><a class="anchor-link" href="#A.-Measuring-the-qubit-frequency-precisely-using-a-Ramsey-experiment-"> </a></h2><p>Now, we determine the qubit frequency to better precision. This is done using a Ramsey pulse sequence. In this pulse sequence, we first apply a $\pi/2$ ("pi over two") pulse, wait some time $\Delta t$, and then apply another $\pi/2$ pulse. Since we are measuring the signal from the qubit at the same frequency as the pulses, we should observe oscillations at the difference in frequency between the applied pulses and the qubit.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://github.com/aasfaw/qiskit-intros/blob/master/dephasing.png?raw=true"></p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Ramsey experiment parameters</span>
<span class="n">time_max_us</span> <span class="o">=</span> <span class="mf">1.8</span>
<span class="n">time_step_us</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="n">times_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">time_max_us</span><span class="p">,</span> <span class="n">time_step_us</span><span class="p">)</span>
<span class="c1"># Convert to ns first (1 us = 1000 ns) and then convert to units of dt</span>
<span class="n">delay_times_dt</span> <span class="o">=</span> <span class="n">times_us</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">dt</span>

<span class="c1"># Drive parameters</span>
<span class="c1"># The drive amplitude for pi/2 is simply half the amplitude of the pi pulse</span>
<span class="n">drive_amp</span> <span class="o">=</span> <span class="n">pi_amp</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1"># x_90 is a concise way to say pi_over_2; i.e., an X rotation of 90 degrees</span>
<span class="n">x90_pulse</span> <span class="o">=</span> <span class="n">pulse_lib</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">drive_samples</span><span class="p">,</span>
                               <span class="n">amp</span><span class="o">=</span><span class="n">drive_amp</span><span class="p">,</span> 
                               <span class="n">sigma</span><span class="o">=</span><span class="n">drive_sigma</span><span class="p">,</span>
                               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x90_pulse&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># create schedules for Ramsey experiment </span>
<span class="n">ramsey_schedules</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">delay</span> <span class="ow">in</span> <span class="n">delay_times_dt</span><span class="p">:</span>
    <span class="n">this_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Ramsey delay = {delay * dt / 1e3} us&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

    <span class="n">ramsey_schedules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_schedule</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Just like for $T_1$ schedules, it will be illuminating to execute the next cell multiple times to inspect a few of the schedules we've made. As you look at increasing indices of <code>ramsey_schedules</code>, the delay between the two $\pi/2$ pulses will increase.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ramsey_schedules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_88_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, we will apply a commonly used experimental trick. We will drive the pulses off-resonance by a known amount, which we will call <code>detuning_MHz</code>. The measured Ramsey signal should show oscillations with frequency near <code>detuning_MHz</code>, with a small offset. This small offset is exactly how far away <code>rough_qubit_frequency</code> was from the qubit frequency.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Execution settings</span>
<span class="n">num_shots</span> <span class="o">=</span> <span class="mi">256</span>

<span class="n">detuning_MHz</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ramsey_frequency</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">rough_qubit_frequency</span> <span class="o">+</span> <span class="n">detuning_MHz</span><span class="o">/</span><span class="mf">1.0e3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ramsey_program</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">ramsey_schedules</span><span class="p">,</span>
                             <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                             <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                             <span class="n">shots</span><span class="o">=</span><span class="n">num_shots</span><span class="p">,</span>
                             <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">ramsey_frequency</span><span class="p">}]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ramsey_schedules</span><span class="p">)</span>
                            <span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ramsey_program</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ramsey_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ramsey_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_us</span><span class="p">)):</span>
    <span class="n">ramsey_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ramsey_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">qubit</span><span class="p">])</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">ramsey_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times_us</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Ramsey Experiment&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay between X90 pulses [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_93_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will fit the data to a sinusoid, and extract the information we are interested in -- namely, $\Delta f$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fit_params</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">ramsey_values</span><span class="p">,</span>
                                 <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">del_f_MHz</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="p">(</span>
                                          <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">del_f_MHz</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span>
                                         <span class="p">),</span>
                                 <span class="p">[</span><span class="mf">2e10</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.25e10</span><span class="p">]</span>
                                <span class="p">)</span>

<span class="c1"># Off-resonance component</span>
<span class="n">_</span><span class="p">,</span> <span class="n">del_f_MHz</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="o">=</span> <span class="n">fit_params</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">ramsey_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;df = </span><span class="si">{del_f_MHz:.2f}</span><span class="s2"> MHz&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times_us</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay between X90 pulses [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Ramsey Experiment&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_95_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we know <code>del_f_MHz</code>, we can update our estimate of the qubit frequency.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">precise_qubit_freq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">rough_qubit_frequency</span> <span class="o">+</span> <span class="p">(</span><span class="n">del_f_MHz</span> <span class="o">-</span> <span class="n">detuning_MHz</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Our updated qubit frequency is now </span><span class="si">{precise_qubit_freq}</span><span class="s2"> GHz. It used to be </span><span class="si">{rough_qubit_frequency}</span><span class="s2"> GHz&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Our updated qubit frequency is now 4.974421 GHz. It used to be 4.97435 GHz
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="B.-Measuring-$T_2$-using-Hahn-echoes-">B. Measuring $T_2$ using Hahn echoes <a id="hahn" /><a class="anchor-link" href="#B.-Measuring-$T_2$-using-Hahn-echoes-"> </a></h2><p>Next, we can measure the coherence time, $T_2$, of our qubit. The pulse sequence used to do this experiment is known as a Hahn echo, a term that comes from the NMR community. A Hahn echo experiment is very similar to the Ramsey experiment above, with an additional $\pi$ pulse between the two $\pi/2$ pulses. The $\pi$ pulse at time $\tau$ reverses the accumulation of phase, and results in an echo at time $2\tau$, where we apply the last $\pi/2$ pulse to do our measurement. The Wikipedia page for Hahn echoes</p>
<p>The decay time for the Hahn echo experiment gives us the coherence time, $T_2$.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># T2 experiment parameters</span>
<span class="n">tau_max_us</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">tau_step_us</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">taus_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">tau_max_us</span><span class="p">,</span> <span class="n">tau_step_us</span><span class="p">)</span>
<span class="c1"># Convert to ns first (1 us = 1000 ns) and then convert to units of dt</span>
<span class="n">delay_times_dt</span> <span class="o">=</span> <span class="n">taus_us</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">dt</span>

<span class="c1"># We will use the pi_pulse and x90_pulse from previous experiments</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t2_schedules</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">delay_times_dt</span><span class="p">:</span>
    <span class="n">this_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T2 delay = </span><span class="si">{tau}</span><span class="s2"> us&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">tau</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
    
    <span class="n">t2_schedules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_schedule</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t2_schedules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_101_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Execution settings</span>
<span class="n">num_shots_per_point</span> <span class="o">=</span> <span class="mi">512</span>

<span class="n">t2_experiment</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t2_schedules</span><span class="p">,</span>
                         <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                         <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                         <span class="n">shots</span><span class="o">=</span><span class="n">num_shots_per_point</span><span class="p">,</span>
                         <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">precise_qubit_freq</span><span class="p">}]</span>
                                      <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2_schedules</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">t2_experiment</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t2_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">t2_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taus_us</span><span class="p">)):</span>
    <span class="n">t2_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t2_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">qubit</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">taus_us</span><span class="p">,</span> <span class="n">t2_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay between X90 pulse and $\pi$ pulse [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Hahn Echo Experiment&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_105_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fit_params</span><span class="p">,</span> <span class="n">y_fit</span> <span class="o">=</span> <span class="n">fit_function</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">taus_us</span><span class="p">,</span> <span class="n">t2_values</span><span class="p">,</span>
             <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">T2</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">T2</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span><span class="p">),</span>
             <span class="p">[</span><span class="o">-</span><span class="mf">1.2e15</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4e15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>

<span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">fit_params</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">taus_us</span><span class="p">,</span> <span class="n">t2_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">taus_us</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T2 = </span><span class="si">{T2:.2f}</span><span class="s2"> us&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">taus_us</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Delay between X90 pulse and $\pi$ pulse [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Hahn Echo Experiment&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>
</pre>
</div>
</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_106_1.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="C.-Dynamical-decoupling-">C. Dynamical decoupling <a id="DD" /><a class="anchor-link" href="#C.-Dynamical-decoupling-"> </a></h2><p>A single $\pi$ pulse is able to eliminate quasi-static noise due to the reversal of phase accumulation. This concept can be extended to noise that cannot be approximated as quasi-static by applying several $\pi$ pulses in succession. This technique, commonly known as dynamical decoupling, allows us to cancel different frequencies of noise and is used to extract longer coherence times from qubits.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># DD experiment parameters</span>
<span class="n">tau_us_min</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">tau_us_max</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">tau_step_us</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">taus_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tau_us_min</span><span class="p">,</span> <span class="n">tau_us_max</span><span class="p">,</span> <span class="n">tau_step_us</span><span class="p">)</span>
<span class="c1"># Convert to dt</span>
<span class="n">taus_dt</span> <span class="o">=</span> <span class="n">taus_us</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">dt</span>
<span class="n">numpipulses</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># apply two pi pulses</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time ranges from {2.*numpipulses*taus_us[0]} to {2.*numpipulses*taus_us[-1]} us&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Total time ranges from 12.0 to 462.0 us
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">T2DD_schedules</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">delay</span> <span class="ow">in</span> <span class="n">taus_dt</span><span class="p">:</span>
    <span class="n">this_schedule</span> <span class="o">=</span> <span class="n">pulse</span><span class="o">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T2DD delay = </span><span class="si">{delay}</span><span class="s2"> us&quot;</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpipulses</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">pi_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">delay</span><span class="p">)</span>

    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">x90_pulse</span><span class="p">(</span><span class="n">drive_chan</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)</span>
    <span class="n">this_schedule</span> <span class="o">|=</span> <span class="n">measure_schedule</span> <span class="o">&lt;&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">this_schedule</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
    
    <span class="n">T2DD_schedules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_schedule</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">T2DD_schedules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">channels_to_plot</span><span class="o">=</span><span class="p">[</span><span class="n">drive_chan</span><span class="p">,</span> <span class="n">meas_chan</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea output_execute_result">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_110_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">num_shots_per_point</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="n">T2DD_experiment</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">T2DD_schedules</span><span class="p">,</span>
                             <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                             <span class="n">meas_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">meas_return</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span>
                             <span class="n">shots</span><span class="o">=</span><span class="n">num_shots_per_point</span><span class="p">,</span>
                             <span class="n">schedule_los</span><span class="o">=</span><span class="p">[{</span><span class="n">drive_chan</span><span class="p">:</span> <span class="n">precise_qubit_freq</span><span class="p">}]</span>
                                          <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">T2DD_schedules</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">T2DD_experiment</span><span class="p">)</span>
<span class="c1"># print(job.job_id())</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Job Status: job has successfully run
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">T2DD_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">times_us</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">numpipulses</span><span class="o">*</span><span class="n">taus_us</span>
<span class="n">DD_values</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taus_us</span><span class="p">)):</span>
    <span class="n">DD_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T2DD_results</span><span class="o">.</span><span class="n">get_memory</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">qubit</span><span class="p">])</span>


<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">DD_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times_us</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Total time before measurement [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Dynamical Decoupling Experiment&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_114_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Fit the data</span>
<span class="n">fit_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">T2DD</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">T2DD</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span>
<span class="n">fitparams</span><span class="p">,</span> <span class="n">conv</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">fit_func</span><span class="p">,</span> <span class="n">times_us</span><span class="p">,</span> <span class="n">DD_values</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.7e10</span><span class="p">,</span> <span class="mf">0.8e10</span><span class="p">,</span> <span class="mi">150</span><span class="p">])</span>

<span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">T2DD</span> <span class="o">=</span> <span class="n">fitparams</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">DD_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="n">fit_func</span><span class="p">(</span><span class="n">times_us</span><span class="p">,</span> <span class="o">*</span><span class="n">fitparams</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;T2DD = </span><span class="si">{T2DD:.2f}</span><span class="s2"> us&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">times_us</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Total time before measurement [$\mu$s]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Measured Signal [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Dynamical Decoupling Experiment&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/ch-quantum-hardware/calibrating-qubits-openpulse_115_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Part-4.-References-">Part 4. References <a id="refs" /><a class="anchor-link" href="#Part-4.-References-"> </a></h1>
</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ol>
<li>H. Abraham, I. Y. Akhalwaya, G. Aleksandrowicz, T. Alexander, G. Alexandrowics, E. Arbel, A. Asfaw, C. Azaustre, P. Barkoutsos, G. Barron, L. Bello, Y. Ben-Haim, L. S. Bishop, S. Bosch, D. Bucher, CZ, F. Cabrera, P. Calpin, L. Capelluto, J. Carballo, C.-F. Chen, A. Chen, R. Chen, J. M. Chow, C. Claus, A. W. Cross, A. J. Cross, J. Cruz- Benito, C. Culver, A. D. C ́orcoles-Gonzales, S. Dague, M. Dartiailh, A. R. Davila, D. Ding, E. Dumitrescu, K. Dumon, I. Duran, P. Eendebak, D. Egger, M. Everitt, P. M. Fern ́andez, A. Frisch, A. Fuhrer, J. Gacon, Gadi, B. G. Gago, J. M. Gambetta, L. Garcia, S. Garion, Gawel-Kus, L. Gil, J. Gomez-Mosquera, S. de la Puente Gonz ́alez, D. Green- berg,J.A.Gunnels,I.Haide,I.Hamamura,V.Havlicek,J.Hellmers,L􏰀.Herok,H.Horii, C. Howington, W. Hu, S. Hu, H. Imai, T. Imamichi, R. Iten, T. Itoko, A. Javadi-Abhari, Jessica, K. Johns, N. Kanazawa, A. Karazeev, P. Kassebaum, V. Krishnan, K. Kr- sulich, G. Kus, R. LaRose, R. Lambert, J. Latone, S. Lawrence, P. Liu, P. B. Z. Mac, Y. Maeng, A. Malyshev, J. Marecek, M. Marques, D. Mathews, A. Matsuo, D. T. Mc- Clure, C. McGarry, D. McKay, S. Meesala, A. Mezzacapo, R. Midha, Z. Minev, P. Mu- rali, J. Mu ̈ggenburg, D. Nadlinger, G. Nannicini, P. Nation, Y. Naveh, Nick-Singstock, P. Niroula, H. Norlen, L. J. O’Riordan, S. Oud, D. Padilha, H. Paik, S. Perriello, A. Phan, M. Pistoia, A. Pozas-iKerstjens, V. Prutyanov, J. P ́erez, Quintiii, R. Raymond, R. M.-C. Redondo, M. Reuter, D. M. Rodr ́ıguez, M. Ryu, M. Sandberg, N. Sathaye, B. Schmitt, C. Schnabel, T. L. Scholten, E. Schoute, I. F. Sertage, Y. Shi, A. Silva, Y. Siraichi, S. Sivarajah, J. A. Smolin, M. Soeken, D. Steenken, M. Stypulkoski, H. Takahashi, C. Taylor, P. Taylour, S. Thomas, M. Tillet, M. Tod, E. de la Torre, K. Trabing, M. Treinish, TrishaPe, W. Turner, Y. Vaknin, C. R. Valcarce, F. Varchon, D. Vogt- Lee, C. Vuillot, J. Weaver, R. Wieczorek, J. A. Wildstrom, R. Wille, E. Winston, J. J. Woehr, S. Woerner, R. Woo, C. J. Wood, R. Wood, S. Wood, J. Wootton, D. Yeralin, J. Yu, L. Zdanski, Zoufalc, azulehner, drholmie, fanizzamarco, kanejess, klinvill, merav aharoni, ordmoj, tigerjack, yang.luh, and yotamvakninibm, “Qiskit: An open-source framework for quantum computing,” 2019.</li>
<li>D. C. McKay, T. Alexander, L. Bello, M. J. Biercuk, L. Bishop, J. Chen, J. M. Chow, A. D. C ́orcoles, D. Egger, S. Filipp, J. Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B. Paulovicks, E. Winston, C. J. Wood, J. Wootton, and J. M. Gambetta, “Qiskit backend specifications for OpenQASM and OpenPulse experiments,” 2018.</li>
</ol>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="o">%</span><span class="k">qiskit_version_table</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">


<div class="output_html rendered_html output_subarea ">
<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td>Qiskit</td><td>0.14.0</td></tr><tr><td>Terra</td><td>0.11.0</td></tr><tr><td>Aer</td><td>0.3.4</td></tr><tr><td>Ignis</td><td>0.2.0</td></tr><tr><td>Aqua</td><td>0.6.1</td></tr><tr><td>IBM Q Provider</td><td>0.4.4</td></tr><tr><th>System information</th></tr><tr><td>Python</td><td>3.7.3 (default, Mar 27 2019, 16:54:48) 
[Clang 4.0.1 (tags/RELEASE_401/final)]</td></tr><tr><td>OS</td><td>Darwin</td></tr><tr><td>CPUs</td><td>6</td></tr><tr><td>Memory (Gb)</td><td>16.0</td></tr><tr><td colspan='2'>Wed Dec 11 01:59:49 2019 SAST</td></tr></table>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

 


    </main>
    
        </div>
        <nav class="c-page__nav">
  
    
    <a id="js-page__nav__prev" class="c-page__nav__prev" href="/textbook/ch-applications/satisfiability-grover.html">
      〈 <span class="u-margin-right-tiny"></span> 
    </a>
  

  
    
    <a id="js-page__nav__next" class="c-page__nav__next" href="/textbook/ch-quantum-hardware/calibrating-qubits-openpulse.html">
       <span class="u-margin-right-tiny"></span> 〉
    </a>
  
</nav>

        <footer>
  <p class="footer">This page was created by <a href="https://github.com/jupyter/jupyter-book/graphs/contributors">The Jupyter Book Community</a></p>
</footer>

      </main>
    </div>
  </body>
</html>
